<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Arcon User Guide</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A User Guide for Arcon.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="getting-started.html">Getting Started</a></li><li class="chapter-item expanded "><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/architecture.html"><strong aria-hidden="true">1.1.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="introduction/data_format.html"><strong aria-hidden="true">1.2.</strong> Data Format</a></li><li class="chapter-item expanded "><a href="introduction/state.html"><strong aria-hidden="true">1.3.</strong> State Management</a></li><li class="chapter-item expanded "><a href="introduction/operators.html"><strong aria-hidden="true">1.4.</strong> Operators</a></li></ol></li><li class="chapter-item expanded "><a href="pipeline/index.html"><strong aria-hidden="true">2.</strong> Pipeline</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pipeline/configuration.html"><strong aria-hidden="true">2.1.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="pipeline/source.html"><strong aria-hidden="true">2.2.</strong> Sources</a></li><li class="chapter-item expanded "><a href="pipeline/stream.html"><strong aria-hidden="true">2.3.</strong> Stream API</a></li><li class="chapter-item expanded "><a href="pipeline/backends.html"><strong aria-hidden="true">2.4.</strong> State Backends</a></li><li class="chapter-item expanded "><a href="pipeline/indexes.html"><strong aria-hidden="true">2.5.</strong> State Indexes</a></li><li class="chapter-item expanded "><a href="pipeline/state.html"><strong aria-hidden="true">2.6.</strong> State Access</a></li></ol></li><li class="chapter-item expanded "><a href="roadmap.html"><strong aria-hidden="true">3.</strong> Roadmap</a></li><li class="chapter-item expanded "><a href="project_info.html"><strong aria-hidden="true">4.</strong> Project Info</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Arcon User Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/cda-group/arcon" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#foreword" id="foreword">Foreword</a></h1>
<p>Arcon is a runtime for writing streaming applications with the Rust programming language.
The runtime is meant to be either used as a standalone library or in the future through the <a href="https://github.com/cda-group/arc">Arc</a> programming language.</p>
<p>Do note that the project is currently in development and should be considered experimental until further notice.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<h2><a class="header" href="#setting-up-rust" id="setting-up-rust">Setting up Rust</a></h2>
<p>The easiest way to install rust is to use the <a href="https://rustup.rs/">rustup</a> tool.</p>
<p>Arcon currently only works on Rust nightly. See the current toolchain that is used <a href="https://github.com/cda-group/arcon/blob/master/rust-toolchain">here</a>.</p>
<h2><a class="header" href="#cargo" id="cargo">Cargo</a></h2>
<p>Add Arcon to your cargo project as a dependency:</p>
<pre><code class="language-toml">[dependencies]
arcon = &quot;LATEST_VERSION&quot;
</code></pre>
<p>The latest version can be found on <a href="https://crates.io/crates/arcon">crates.io</a>.</p>
<h3><a class="header" href="#github-dependency" id="github-dependency">Github Dependency</a></h3>
<p>You may also add Arcon as a git dependency through Cargo. The following will use the latest master version</p>
<pre><code class="language-toml">[dependencies]
arcon = { git = &quot;https://github.com/cda-group/arcon&quot; }
</code></pre>
<h2><a class="header" href="#basic-example" id="basic-example">Basic Example</a></h2>
<pre><code class="language-rust edition2018 no_run noplaypen">use arcon::prelude::*;

fn main() {
    let mut pipeline = Pipeline::default()
        .collection((0..100).collect::&lt;Vec&lt;u64&gt;&gt;(), |conf| {
            conf.set_arcon_time(ArconTime::Event);
            conf.set_timestamp_extractor(|x: &amp;u64| *x);
        })
        .operator(OperatorBuilder {
            constructor: Arc::new(|_| Filter::new(|x| *x &gt; 50)),
            conf: Default::default(),
        })
        .operator(OperatorBuilder {
            constructor: Arc::new(|_| Map::new(|x| x + 10)),
            conf: Default::default(),
        })
        .to_console()
        .build();

    pipeline.start();
    pipeline.await_termination();
}
</code></pre>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>This section covers the key concepts of Arcon.</p>
<h1><a class="header" href="#architecture" id="architecture">Architecture</a></h1>
<p>At the core of Arcon is the hybrid component + actor model framework <a href="https://github.com/kompics/kompact">Kompact</a>.
Arcon does not use dedicated threads, but rather relies on the work-stealing scheduler of Kompact to drive the execution of a streaming application.</p>
<p>This section is divided into the following sub-sections:</p>
<ul>
<li><a href="introduction/architecture.html#runtime-components">Runtime Components</a></li>
<li><a href="introduction/architecture.html#pipeline">Pipeline</a></li>
</ul>
<h2><a class="header" href="#runtime-components" id="runtime-components">Runtime Components</a></h2>
<h3><a class="header" href="#source-node" id="source-node">Source Node</a></h3>
<p>To be added.</p>
<h3><a class="header" href="#node" id="node">Node</a></h3>
<p>A Node is a Kompact component that drives the execution a user-defined Arcon <a href="introduction/operators.html">Operator</a>. 
An Operator may either be stateless or stateful. More on how state is handled is discussed in
<a href="introduction/state.html">State Management</a>. </p>
<p><img src="introduction/arcon_node.jpg" alt="" /></p>
<p>The image below illustrates how Arcon nodes are scheduled by Kompact.</p>
<p><img src="introduction/scheduler.jpg" alt="" /></p>
<h2><a class="header" href="#pipeline" id="pipeline">Pipeline</a></h2>
<p>To be added.</p>
<h1><a class="header" href="#data-format" id="data-format">Data Format</a></h1>
<p>The main data format of Arcon is Protobuf. There are several reasons behind this choice and they are listed below:</p>
<ol>
<li>Universal data format that enables the data to be moved outside of the Rust ecosystem. </li>
<li>Supports schema evolution.</li>
<li>Good space utilisation on disk.</li>
<li>Decent serialisation/deserialisation cost.</li>
</ol>
<p>Serialised size of two different Rust structs (<a href="https://github.com/cda-group/arcon/blob/master/benches/serde.rs">Reference</a>):</p>
<table><thead><tr><th>Framework</th><th>Small</th><th>Large</th></tr></thead><tbody>
<tr><td>Protobuf</td><td>14 bytes</td><td>106 bytes</td></tr>
<tr><td>Serde::Bincode</td><td>20 bytes</td><td>228 bytes</td></tr>
</tbody></table>
<p>Arcon uses the <a href="https://github.com/danburkert/prost">prost</a> crate to define its data types directly in Rust or through .proto files.</p>
<p>The section is divided into the following sub-sections:</p>
<ul>
<li><a href="introduction/data_format.html#arcontype">ArconType</a></li>
<li><a href="introduction/data_format.html#declaring-arcontype-directly-in-rust">Declaring ArconType directly in Rust</a></li>
<li><a href="introduction/data_format.html#generating-arcontype-from-proto-files">Generating ArconType from proto files</a></li>
</ul>
<h2><a class="header" href="#arcontype" id="arcontype">ArconType</a></h2>
<p>Data that is passed through the runtime must implement <code>ArconType</code>. There are a few mandatory attributes
that must be added:</p>
<ul>
<li><code>version</code> An integer representing the version</li>
<li><code>reliable_ser_id</code> An integer representing the version used for in-flight serialisation</li>
<li><code>keys</code> fields that should be used to hash the key
<ul>
<li>If not specified, it will pick all hashable fields.</li>
<li>The Arcon derive macro will estimate the amount of bytes for the selected fields
and pick a suitable hasher.</li>
</ul>
</li>
<li><code>unsafe_ser_id</code> An integer representing the unsafe in-flight serde if the <strong>unsafe_flight</strong> feature is enabled.</li>
</ul>
<h2><a class="header" href="#declaring-arcontype-directly-in-rust" id="declaring-arcontype-directly-in-rust">Declaring ArconType directly in Rust</a></h2>
<p>First make sure that you have also added prost as a dependency.</p>
<pre><code class="language-toml">[dependencies]
arcon = &quot;LATEST_VERSION&quot;
prost = &quot;ARCON_PROST_VERSION&quot;
</code></pre>
<p>Then you can directly declare ArconTypes by using the <code>Arcon</code> derive macro together with the <code>Prost</code> macro:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use arcon::prelude::*;
</span><span class="boring">use examples::SnapshotComponent;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">
</span><span class="boring">#[cfg_attr(feature = &quot;arcon_serde&quot;, derive(serde::Deserialize, serde::Serialize))]
</span><span class="boring">#[cfg_attr(feature = &quot;unsafe_flight&quot;, derive(abomonation_derive::Abomonation))]
</span>#[derive(Arcon, Arrow, prost::Message, Copy, Clone)]
#[arcon(unsafe_ser_id = 12, reliable_ser_id = 13, version = 1, keys = &quot;id&quot;)]
pub struct Event {
    #[prost(uint64)]
    pub id: u64,
    #[prost(float)]
    pub data: f32,
}
<span class="boring">
</span><span class="boring">#[derive(ArconState)]
</span><span class="boring">pub struct MyState&lt;B: Backend&gt; {
</span><span class="boring">    #[table = &quot;events&quot;]
</span><span class="boring">    events: EagerValue&lt;Event, B&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;B: Backend&gt; StateConstructor for MyState&lt;B&gt; {
</span><span class="boring">    type BackendType = B;
</span><span class="boring">
</span><span class="boring">    fn new(backend: Arc&lt;Self::BackendType&gt;) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            events: EagerValue::new(&quot;_events&quot;, backend),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let conf = ArconConf {
</span><span class="boring">        epoch_interval: 2500,
</span><span class="boring">        ctrl_system_host: Some(&quot;127.0.0.1:2000&quot;.to_string()),
</span><span class="boring">        ..Default::default()
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let mut pipeline = Pipeline::with_conf(conf)
</span><span class="boring">        .collection(
</span><span class="boring">            (0..1000000)
</span><span class="boring">                .map(|x| Event { id: x, data: 1.5 })
</span><span class="boring">                .collect::&lt;Vec&lt;Event&gt;&gt;(),
</span><span class="boring">            |conf| {
</span><span class="boring">                conf.set_timestamp_extractor(|x: &amp;Event| x.id);
</span><span class="boring">            },
</span><span class="boring">        )
</span><span class="boring">        .operator(OperatorBuilder {
</span><span class="boring">            constructor: Arc::new(|backend| {
</span><span class="boring">                Map::stateful(MyState::new(backend), |event, state| {
</span><span class="boring">                    state.events().put(event)?;
</span><span class="boring">                    Ok(event)
</span><span class="boring">                })
</span><span class="boring">            }),
</span><span class="boring">            conf: Default::default(),
</span><span class="boring">        })
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    pipeline.watch(|epoch: u64, _: MyState&lt;Sled&gt;| {
</span><span class="boring">        println!(&quot;Got state object for epoch {}&quot;, epoch);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let kompact_system = KompactConfig::default().build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">    // Create Kompact component to receive snapshots
</span><span class="boring">    let snapshot_comp = kompact_system.create(SnapshotComponent::new);
</span><span class="boring">
</span><span class="boring">    kompact_system
</span><span class="boring">        .start_notify(&amp;snapshot_comp)
</span><span class="boring">        .wait_timeout(std::time::Duration::from_millis(200))
</span><span class="boring">        .expect(&quot;Failed to start component&quot;);
</span><span class="boring">
</span><span class="boring">    pipeline.watch_with::&lt;MyState&lt;Sled&gt;&gt;(snapshot_comp);
</span><span class="boring">
</span><span class="boring">    pipeline.start();
</span><span class="boring">    pipeline.await_termination();
</span><span class="boring">}
</span></code></pre>
<h2><a class="header" href="#generating-arcontype-from-proto-files" id="generating-arcontype-from-proto-files">Generating ArconType from .proto files</a></h2>
<p>Down below is an example of the same <code>Event</code> struct as defined above. Note that
the mandatory attributes are gathered through regular <code>//</code> comments.</p>
<pre><code class="language-proto">syntax = &quot;proto3&quot;;

package event;

// reliable_ser_id = 101
// unsafe_ser_id = 102
// version = 1
message Event {
  uint64 id = 1;
}
</code></pre>
<p>We then need to use the <code>arcon_build</code> crate to generate the Protobuf messages into Arcon supported data.</p>
<pre><code class="language-toml">[build-dependencies]
arcon_build = &quot;ARCON_VERSION&quot;
</code></pre>
<p>Add a <code>build.rs</code> file and change the paths if necessary.</p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    arcon_build::compile_protos(&amp;[&quot;src/event.proto&quot;], &amp;[&quot;src/&quot;]).unwrap();
    Ok(())
}
</code></pre></pre>
<p>The build script will then generate the .rs files and you can
include the generated data into an Arcon application by doing the following:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">use arcon::prelude::*;

// bring Event into scope
include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/event.rs&quot;));

fn main() {
    let mut pipeline = Pipeline::default()
        .collection(
            (0..10000000)
                .map(|x| Event { id: x })
                .collect::&lt;Vec&lt;Event&gt;&gt;(),
            |conf| {
                conf.set_timestamp_extractor(|x: &amp;Event| x.id);
            },
        )
        .operator(OperatorBuilder {
            constructor: Arc::new(|_| Filter::new(|event: &amp;Event| event.id &gt; 50)),
            conf: Default::default(),
        })
        .build();

    pipeline.start();
    pipeline.await_termination();
}
</code></pre>
<h1><a class="header" href="#state-management" id="state-management">State Management</a></h1>
<p>In this section, we will cover how Arcon approaches state.</p>
<p>Arcon makes a clear separation between active and historical state. Active state is maintained in in-memory indexes, while cold state is pushed down to a durable state backend. Other streaming systems commonly operate directly on the latter (e.g., RocksDB). This has several drawbacks. Typically the state backends are general-purpose key-value stores and are thus not specialised for streaming workloads. 
The state access pattern is not considered at all. Secondly, state calls have to serialise/deserialise for each operation.</p>
<p>Similarly to other streaming systems, Arcon operates on epoch boundaries. 
Therefore it is only necessary to persist modified state prior to running the epoch snapshotting protocol. 
Deserialisation in Protobuf (Arcon’s data format) compared to serialisation is costly.
Which is why Arcon favours serialisation overhead over its deserialisation counterpart and thus state in Arcon is lazy by default.</p>
<p>As implementing a custom state backend specialised for streaming would require a huge engineering effort, Arcon adds the
<strong>Active State</strong> layer above existing state backends (See image below). The idea is to use the state backends for what they are good at, that is,
storing state efficiently on disk and checkpointing.</p>
<p><img src="introduction/arcon_state_layer.PNG" alt="" /></p>
<p>However, for some workloads it may make sense to directly use the underlying state backend. 
Arcon provides an <strong>eager</strong> version of all active state indexes. So for example,
<code>Map</code> is by default lazy while <code>EagerMap</code> operates directly on the state backend. If your map workload is
mostly writes and not much reads, then using the latter would be more suitable.</p>
<p>Arcon enables users to configure different state backends for different stages of the dataflow graph. For write-heavy workloads,
users may want to use <code>RocksDB</code> (LSM) as the state backend. Whereas for read-heavy workloads, <code>Sled</code> may be a better fit.</p>
<h2><a class="header" href="#declaring-arcon-state" id="declaring-arcon-state">Declaring Arcon State</a></h2>
<p>State in Arcon must implement the trait <code>ArconState</code>. The simpliest way 
to acheive this is to use the provided derive macro.</p>
<p>Let’s say that we would want to store our <code>Event</code> records
in an <code>Appender</code> index.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use arcon::prelude::*;
</span><span class="boring">use examples::SnapshotComponent;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">
</span><span class="boring">#[cfg_attr(feature = &quot;arcon_serde&quot;, derive(serde::Deserialize, serde::Serialize))]
</span><span class="boring">#[cfg_attr(feature = &quot;unsafe_flight&quot;, derive(abomonation_derive::Abomonation))]
</span>#[derive(Arcon, Arrow, prost::Message, Copy, Clone)]
#[arcon(unsafe_ser_id = 12, reliable_ser_id = 13, version = 1, keys = &quot;id&quot;)]
pub struct Event {
    #[prost(uint64)]
    pub id: u64,
    #[prost(float)]
    pub data: f32,
}
<span class="boring">
</span><span class="boring">#[derive(ArconState)]
</span><span class="boring">pub struct MyState&lt;B: Backend&gt; {
</span><span class="boring">    #[table = &quot;events&quot;]
</span><span class="boring">    events: EagerValue&lt;Event, B&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;B: Backend&gt; StateConstructor for MyState&lt;B&gt; {
</span><span class="boring">    type BackendType = B;
</span><span class="boring">
</span><span class="boring">    fn new(backend: Arc&lt;Self::BackendType&gt;) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            events: EagerValue::new(&quot;_events&quot;, backend),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let conf = ArconConf {
</span><span class="boring">        epoch_interval: 2500,
</span><span class="boring">        ctrl_system_host: Some(&quot;127.0.0.1:2000&quot;.to_string()),
</span><span class="boring">        ..Default::default()
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let mut pipeline = Pipeline::with_conf(conf)
</span><span class="boring">        .collection(
</span><span class="boring">            (0..1000000)
</span><span class="boring">                .map(|x| Event { id: x, data: 1.5 })
</span><span class="boring">                .collect::&lt;Vec&lt;Event&gt;&gt;(),
</span><span class="boring">            |conf| {
</span><span class="boring">                conf.set_timestamp_extractor(|x: &amp;Event| x.id);
</span><span class="boring">            },
</span><span class="boring">        )
</span><span class="boring">        .operator(OperatorBuilder {
</span><span class="boring">            constructor: Arc::new(|backend| {
</span><span class="boring">                Map::stateful(MyState::new(backend), |event, state| {
</span><span class="boring">                    state.events().put(event)?;
</span><span class="boring">                    Ok(event)
</span><span class="boring">                })
</span><span class="boring">            }),
</span><span class="boring">            conf: Default::default(),
</span><span class="boring">        })
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    pipeline.watch(|epoch: u64, _: MyState&lt;Sled&gt;| {
</span><span class="boring">        println!(&quot;Got state object for epoch {}&quot;, epoch);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let kompact_system = KompactConfig::default().build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">    // Create Kompact component to receive snapshots
</span><span class="boring">    let snapshot_comp = kompact_system.create(SnapshotComponent::new);
</span><span class="boring">
</span><span class="boring">    kompact_system
</span><span class="boring">        .start_notify(&amp;snapshot_comp)
</span><span class="boring">        .wait_timeout(std::time::Duration::from_millis(200))
</span><span class="boring">        .expect(&quot;Failed to start component&quot;);
</span><span class="boring">
</span><span class="boring">    pipeline.watch_with::&lt;MyState&lt;Sled&gt;&gt;(snapshot_comp);
</span><span class="boring">
</span><span class="boring">    pipeline.start();
</span><span class="boring">    pipeline.await_termination();
</span><span class="boring">}
</span></code></pre>
<p>We then create our custom state object <code>MyState</code> and add the
state indexes as fields. Do note that the <code>ArconState</code> derive macro
will require each field to be an Arcon implemented index. However if you
want to access some non-durable field, then you may add the <code>#[ephemeral]</code> flag
above the field.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use arcon::prelude::*;
</span><span class="boring">use examples::SnapshotComponent;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">
</span><span class="boring">#[cfg_attr(feature = &quot;arcon_serde&quot;, derive(serde::Deserialize, serde::Serialize))]
</span><span class="boring">#[cfg_attr(feature = &quot;unsafe_flight&quot;, derive(abomonation_derive::Abomonation))]
</span><span class="boring">#[derive(Arcon, Arrow, prost::Message, Copy, Clone)]
</span><span class="boring">#[arcon(unsafe_ser_id = 12, reliable_ser_id = 13, version = 1, keys = &quot;id&quot;)]
</span><span class="boring">pub struct Event {
</span><span class="boring">    #[prost(uint64)]
</span><span class="boring">    pub id: u64,
</span><span class="boring">    #[prost(float)]
</span><span class="boring">    pub data: f32,
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(ArconState)]
pub struct MyState&lt;B: Backend&gt; {
    #[table = &quot;events&quot;]
    events: EagerValue&lt;Event, B&gt;,
}

impl&lt;B: Backend&gt; StateConstructor for MyState&lt;B&gt; {
    type BackendType = B;

    fn new(backend: Arc&lt;Self::BackendType&gt;) -&gt; Self {
        Self {
            events: EagerValue::new(&quot;_events&quot;, backend),
        }
    }
}

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let conf = ArconConf {
</span><span class="boring">        epoch_interval: 2500,
</span><span class="boring">        ctrl_system_host: Some(&quot;127.0.0.1:2000&quot;.to_string()),
</span><span class="boring">        ..Default::default()
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let mut pipeline = Pipeline::with_conf(conf)
</span><span class="boring">        .collection(
</span><span class="boring">            (0..1000000)
</span><span class="boring">                .map(|x| Event { id: x, data: 1.5 })
</span><span class="boring">                .collect::&lt;Vec&lt;Event&gt;&gt;(),
</span><span class="boring">            |conf| {
</span><span class="boring">                conf.set_timestamp_extractor(|x: &amp;Event| x.id);
</span><span class="boring">            },
</span><span class="boring">        )
</span><span class="boring">        .operator(OperatorBuilder {
</span><span class="boring">            constructor: Arc::new(|backend| {
</span><span class="boring">                Map::stateful(MyState::new(backend), |event, state| {
</span><span class="boring">                    state.events().put(event)?;
</span><span class="boring">                    Ok(event)
</span><span class="boring">                })
</span><span class="boring">            }),
</span><span class="boring">            conf: Default::default(),
</span><span class="boring">        })
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    pipeline.watch(|epoch: u64, _: MyState&lt;Sled&gt;| {
</span><span class="boring">        println!(&quot;Got state object for epoch {}&quot;, epoch);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let kompact_system = KompactConfig::default().build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">    // Create Kompact component to receive snapshots
</span><span class="boring">    let snapshot_comp = kompact_system.create(SnapshotComponent::new);
</span><span class="boring">
</span><span class="boring">    kompact_system
</span><span class="boring">        .start_notify(&amp;snapshot_comp)
</span><span class="boring">        .wait_timeout(std::time::Duration::from_millis(200))
</span><span class="boring">        .expect(&quot;Failed to start component&quot;);
</span><span class="boring">
</span><span class="boring">    pipeline.watch_with::&lt;MyState&lt;Sled&gt;&gt;(snapshot_comp);
</span><span class="boring">
</span><span class="boring">    pipeline.start();
</span><span class="boring">    pipeline.await_termination();
</span><span class="boring">}
</span></code></pre>
<p>Examples of more state indexes can be found <a href="introduction/../pipeline/indexes.html">here</a>.</p>
<h1><a class="header" href="#operators" id="operators">Operators</a></h1>
<p>A streaming operator takes data and executes some form of transformation before
sending it downstream to other operators as part of a larger dataflow graph.</p>
<p>Arcon provides a set of pre-defined operators such as map, filter, and flatmap. However, it is also
possible to implement your own Operator.</p>
<p>An <code>Operator</code> has 4 associated types:</p>
<ul>
<li><code>IN</code> The type data flowing into the operator</li>
<li><code>OUT</code> The output type of the executed transformation</li>
<li><code>TimerState</code> If a timer is used, one may specify a type of timer state.</li>
<li><code>OperatorState</code> Custom defined user state that is of type ArconState.</li>
</ul>
<p>and 3 required methods to implement:</p>
<ul>
<li><code>handle_element</code> This method is called on each new streaming record that comes</li>
<li><code>handle_timeout</code> This method handles custom triggered timers that have been scheduled through the <code>OperatorContext</code></li>
<li><code>handle_persist</code> This method defines how custom defined OperatorState shall be persisted.</li>
</ul>
<p>If you do not care about dealing with timers or handling state, you may simply ignore these
methods by using the <code>ignore_timeout!()</code> and <code>ignore_persist!()</code> macros that add empty implementations.</p>
<p>Both <code>handle_element</code> and <code>handle_timeout</code> has access to an <code>OperatorContext</code>. From this context, you may
output events, schedule timers, and also perform some logging.</p>
<h2><a class="header" href="#creating-an-operator" id="creating-an-operator">Creating an Operator</a></h2>
<p>To showcase the Operator interface, we will now create two custom Operators. One that is very basic and
another that uses the timer facilities.</p>
<p>Down below we have created an Operator called <code>MyOperator</code>, it receives u64s and outputs a CustomEvent.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use arcon::{ignore_persist, ignore_timeout, prelude::*};
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">
</span><span class="boring">#[cfg_attr(feature = &quot;arcon_serde&quot;, derive(serde::Deserialize, serde::Serialize))]
</span><span class="boring">#[cfg_attr(feature = &quot;unsafe_flight&quot;, derive(abomonation_derive::Abomonation))]
</span><span class="boring">#[derive(Arcon, prost::Message, Copy, Clone)]
</span><span class="boring">#[arcon(unsafe_ser_id = 12, reliable_ser_id = 13, version = 1)]
</span><span class="boring">pub struct CustomEvent {
</span><span class="boring">    #[prost(uint64, tag = &quot;1&quot;)]
</span><span class="boring">    pub id: u64,
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Default)]
pub struct MyOperator(EmptyState);

impl Operator for MyOperator {
    type IN = u64;
    type OUT = CustomEvent;
    type TimerState = ArconNever;
    type OperatorState = ();

    fn handle_element(
        &amp;mut self,
        element: ArconElement&lt;Self::IN&gt;,
        mut ctx: OperatorContext&lt;Self, impl Backend, impl ComponentDefinition&gt;,
    ) -&gt; OperatorResult&lt;()&gt; {
        let custom_event = CustomEvent { id: element.data };

        ctx.output(ArconElement {
            data: custom_event,
            timestamp: element.timestamp,
        });

        Ok(())
    }
    ignore_timeout!();
    ignore_persist!();

    fn state(&amp;mut self) -&gt; &amp;mut Self::OperatorState {
        &amp;mut self.0
    }
}
<span class="boring">
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct TimerOperator(EmptyState);
</span><span class="boring">
</span><span class="boring">impl Operator for TimerOperator {
</span><span class="boring">    type IN = CustomEvent;
</span><span class="boring">    type OUT = CustomEvent;
</span><span class="boring">    type TimerState = u64;
</span><span class="boring">    type OperatorState = ();
</span><span class="boring">
</span><span class="boring">    fn handle_element(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        element: ArconElement&lt;Self::IN&gt;,
</span><span class="boring">        mut ctx: OperatorContext&lt;Self, impl Backend, impl ComponentDefinition&gt;,
</span><span class="boring">    ) -&gt; OperatorResult&lt;()&gt; {
</span><span class="boring">        let current_time = ctx.current_time()?;
</span><span class="boring">        let key = element.data.get_key();
</span><span class="boring">        let time = current_time + 1000;
</span><span class="boring">
</span><span class="boring">        if let Err(err) = ctx.schedule_at(key, time, element.data.id) {
</span><span class="boring">            error!(ctx.log(), &quot;Failed to schedule timer with err {}&quot;, err);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ctx.output(element);
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        timeout: Self::TimerState,
</span><span class="boring">        ctx: OperatorContext&lt;Self, impl Backend, impl ComponentDefinition&gt;,
</span><span class="boring">    ) -&gt; OperatorResult&lt;()&gt; {
</span><span class="boring">        info!(ctx.log(), &quot;Got a timer timeout for {:?}&quot;, timeout);
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    ignore_persist!();
</span><span class="boring">
</span><span class="boring">    fn state(&amp;mut self) -&gt; &amp;mut Self::OperatorState {
</span><span class="boring">        &amp;mut self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut pipeline = Pipeline::default()
</span><span class="boring">        .collection((0..10000000).collect::&lt;Vec&lt;u64&gt;&gt;(), |conf| {
</span><span class="boring">            conf.set_timestamp_extractor(|x: &amp;u64| *x);
</span><span class="boring">        })
</span><span class="boring">        .operator(OperatorBuilder {
</span><span class="boring">            constructor: Arc::new(|_| MyOperator::default()),
</span><span class="boring">            conf: Default::default(),
</span><span class="boring">        })
</span><span class="boring">        .operator(OperatorBuilder {
</span><span class="boring">            constructor: Arc::new(|_| TimerOperator::default()),
</span><span class="boring">            conf: Default::default(),
</span><span class="boring">        })
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    pipeline.start();
</span><span class="boring">    pipeline.await_termination();
</span><span class="boring">}
</span></code></pre>
<p>For context, this is how the CustomEvent struct looks like.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use arcon::{ignore_persist, ignore_timeout, prelude::*};
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">
</span><span class="boring">#[cfg_attr(feature = &quot;arcon_serde&quot;, derive(serde::Deserialize, serde::Serialize))]
</span><span class="boring">#[cfg_attr(feature = &quot;unsafe_flight&quot;, derive(abomonation_derive::Abomonation))]
</span>#[derive(Arcon, prost::Message, Copy, Clone)]
#[arcon(unsafe_ser_id = 12, reliable_ser_id = 13, version = 1)]
pub struct CustomEvent {
    #[prost(uint64, tag = &quot;1&quot;)]
    pub id: u64,
}
<span class="boring">
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct MyOperator(EmptyState);
</span><span class="boring">
</span><span class="boring">impl Operator for MyOperator {
</span><span class="boring">    type IN = u64;
</span><span class="boring">    type OUT = CustomEvent;
</span><span class="boring">    type TimerState = ArconNever;
</span><span class="boring">    type OperatorState = ();
</span><span class="boring">
</span><span class="boring">    fn handle_element(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        element: ArconElement&lt;Self::IN&gt;,
</span><span class="boring">        mut ctx: OperatorContext&lt;Self, impl Backend, impl ComponentDefinition&gt;,
</span><span class="boring">    ) -&gt; OperatorResult&lt;()&gt; {
</span><span class="boring">        let custom_event = CustomEvent { id: element.data };
</span><span class="boring">
</span><span class="boring">        ctx.output(ArconElement {
</span><span class="boring">            data: custom_event,
</span><span class="boring">            timestamp: element.timestamp,
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">    ignore_timeout!();
</span><span class="boring">    ignore_persist!();
</span><span class="boring">
</span><span class="boring">    fn state(&amp;mut self) -&gt; &amp;mut Self::OperatorState {
</span><span class="boring">        &amp;mut self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct TimerOperator(EmptyState);
</span><span class="boring">
</span><span class="boring">impl Operator for TimerOperator {
</span><span class="boring">    type IN = CustomEvent;
</span><span class="boring">    type OUT = CustomEvent;
</span><span class="boring">    type TimerState = u64;
</span><span class="boring">    type OperatorState = ();
</span><span class="boring">
</span><span class="boring">    fn handle_element(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        element: ArconElement&lt;Self::IN&gt;,
</span><span class="boring">        mut ctx: OperatorContext&lt;Self, impl Backend, impl ComponentDefinition&gt;,
</span><span class="boring">    ) -&gt; OperatorResult&lt;()&gt; {
</span><span class="boring">        let current_time = ctx.current_time()?;
</span><span class="boring">        let key = element.data.get_key();
</span><span class="boring">        let time = current_time + 1000;
</span><span class="boring">
</span><span class="boring">        if let Err(err) = ctx.schedule_at(key, time, element.data.id) {
</span><span class="boring">            error!(ctx.log(), &quot;Failed to schedule timer with err {}&quot;, err);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ctx.output(element);
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        timeout: Self::TimerState,
</span><span class="boring">        ctx: OperatorContext&lt;Self, impl Backend, impl ComponentDefinition&gt;,
</span><span class="boring">    ) -&gt; OperatorResult&lt;()&gt; {
</span><span class="boring">        info!(ctx.log(), &quot;Got a timer timeout for {:?}&quot;, timeout);
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    ignore_persist!();
</span><span class="boring">
</span><span class="boring">    fn state(&amp;mut self) -&gt; &amp;mut Self::OperatorState {
</span><span class="boring">        &amp;mut self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut pipeline = Pipeline::default()
</span><span class="boring">        .collection((0..10000000).collect::&lt;Vec&lt;u64&gt;&gt;(), |conf| {
</span><span class="boring">            conf.set_timestamp_extractor(|x: &amp;u64| *x);
</span><span class="boring">        })
</span><span class="boring">        .operator(OperatorBuilder {
</span><span class="boring">            constructor: Arc::new(|_| MyOperator::default()),
</span><span class="boring">            conf: Default::default(),
</span><span class="boring">        })
</span><span class="boring">        .operator(OperatorBuilder {
</span><span class="boring">            constructor: Arc::new(|_| TimerOperator::default()),
</span><span class="boring">            conf: Default::default(),
</span><span class="boring">        })
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    pipeline.start();
</span><span class="boring">    pipeline.await_termination();
</span><span class="boring">}
</span></code></pre>
<p>We then create another Operator called <code>TimerOperator</code> that receives CustomEvent’s and
schedules a timer event of u64 in the future when the event time reaches <code>current_time + 1000</code>.
The timer event is scheduled based on the key of the ArconType. Only one timer event can exist 
per key.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use arcon::{ignore_persist, ignore_timeout, prelude::*};
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">
</span><span class="boring">#[cfg_attr(feature = &quot;arcon_serde&quot;, derive(serde::Deserialize, serde::Serialize))]
</span><span class="boring">#[cfg_attr(feature = &quot;unsafe_flight&quot;, derive(abomonation_derive::Abomonation))]
</span><span class="boring">#[derive(Arcon, prost::Message, Copy, Clone)]
</span><span class="boring">#[arcon(unsafe_ser_id = 12, reliable_ser_id = 13, version = 1)]
</span><span class="boring">pub struct CustomEvent {
</span><span class="boring">    #[prost(uint64, tag = &quot;1&quot;)]
</span><span class="boring">    pub id: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct MyOperator(EmptyState);
</span><span class="boring">
</span><span class="boring">impl Operator for MyOperator {
</span><span class="boring">    type IN = u64;
</span><span class="boring">    type OUT = CustomEvent;
</span><span class="boring">    type TimerState = ArconNever;
</span><span class="boring">    type OperatorState = ();
</span><span class="boring">
</span><span class="boring">    fn handle_element(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        element: ArconElement&lt;Self::IN&gt;,
</span><span class="boring">        mut ctx: OperatorContext&lt;Self, impl Backend, impl ComponentDefinition&gt;,
</span><span class="boring">    ) -&gt; OperatorResult&lt;()&gt; {
</span><span class="boring">        let custom_event = CustomEvent { id: element.data };
</span><span class="boring">
</span><span class="boring">        ctx.output(ArconElement {
</span><span class="boring">            data: custom_event,
</span><span class="boring">            timestamp: element.timestamp,
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">    ignore_timeout!();
</span><span class="boring">    ignore_persist!();
</span><span class="boring">
</span><span class="boring">    fn state(&amp;mut self) -&gt; &amp;mut Self::OperatorState {
</span><span class="boring">        &amp;mut self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Default)]
pub struct TimerOperator(EmptyState);

impl Operator for TimerOperator {
    type IN = CustomEvent;
    type OUT = CustomEvent;
    type TimerState = u64;
    type OperatorState = ();

    fn handle_element(
        &amp;mut self,
        element: ArconElement&lt;Self::IN&gt;,
        mut ctx: OperatorContext&lt;Self, impl Backend, impl ComponentDefinition&gt;,
    ) -&gt; OperatorResult&lt;()&gt; {
        let current_time = ctx.current_time()?;
        let key = element.data.get_key();
        let time = current_time + 1000;

        if let Err(err) = ctx.schedule_at(key, time, element.data.id) {
            error!(ctx.log(), &quot;Failed to schedule timer with err {}&quot;, err);
        }

        ctx.output(element);

        Ok(())
    }

    fn handle_timeout(
        &amp;mut self,
        timeout: Self::TimerState,
        ctx: OperatorContext&lt;Self, impl Backend, impl ComponentDefinition&gt;,
    ) -&gt; OperatorResult&lt;()&gt; {
        info!(ctx.log(), &quot;Got a timer timeout for {:?}&quot;, timeout);
        Ok(())
    }

    ignore_persist!();

    fn state(&amp;mut self) -&gt; &amp;mut Self::OperatorState {
        &amp;mut self.0
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut pipeline = Pipeline::default()
</span><span class="boring">        .collection((0..10000000).collect::&lt;Vec&lt;u64&gt;&gt;(), |conf| {
</span><span class="boring">            conf.set_timestamp_extractor(|x: &amp;u64| *x);
</span><span class="boring">        })
</span><span class="boring">        .operator(OperatorBuilder {
</span><span class="boring">            constructor: Arc::new(|_| MyOperator::default()),
</span><span class="boring">            conf: Default::default(),
</span><span class="boring">        })
</span><span class="boring">        .operator(OperatorBuilder {
</span><span class="boring">            constructor: Arc::new(|_| TimerOperator::default()),
</span><span class="boring">            conf: Default::default(),
</span><span class="boring">        })
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    pipeline.start();
</span><span class="boring">    pipeline.await_termination();
</span><span class="boring">}
</span></code></pre>
<p>Finally, we create a simple Pipeline to that uses our custom operators.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use arcon::{ignore_persist, ignore_timeout, prelude::*};
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">
</span><span class="boring">#[cfg_attr(feature = &quot;arcon_serde&quot;, derive(serde::Deserialize, serde::Serialize))]
</span><span class="boring">#[cfg_attr(feature = &quot;unsafe_flight&quot;, derive(abomonation_derive::Abomonation))]
</span><span class="boring">#[derive(Arcon, prost::Message, Copy, Clone)]
</span><span class="boring">#[arcon(unsafe_ser_id = 12, reliable_ser_id = 13, version = 1)]
</span><span class="boring">pub struct CustomEvent {
</span><span class="boring">    #[prost(uint64, tag = &quot;1&quot;)]
</span><span class="boring">    pub id: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct MyOperator(EmptyState);
</span><span class="boring">
</span><span class="boring">impl Operator for MyOperator {
</span><span class="boring">    type IN = u64;
</span><span class="boring">    type OUT = CustomEvent;
</span><span class="boring">    type TimerState = ArconNever;
</span><span class="boring">    type OperatorState = ();
</span><span class="boring">
</span><span class="boring">    fn handle_element(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        element: ArconElement&lt;Self::IN&gt;,
</span><span class="boring">        mut ctx: OperatorContext&lt;Self, impl Backend, impl ComponentDefinition&gt;,
</span><span class="boring">    ) -&gt; OperatorResult&lt;()&gt; {
</span><span class="boring">        let custom_event = CustomEvent { id: element.data };
</span><span class="boring">
</span><span class="boring">        ctx.output(ArconElement {
</span><span class="boring">            data: custom_event,
</span><span class="boring">            timestamp: element.timestamp,
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">    ignore_timeout!();
</span><span class="boring">    ignore_persist!();
</span><span class="boring">
</span><span class="boring">    fn state(&amp;mut self) -&gt; &amp;mut Self::OperatorState {
</span><span class="boring">        &amp;mut self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct TimerOperator(EmptyState);
</span><span class="boring">
</span><span class="boring">impl Operator for TimerOperator {
</span><span class="boring">    type IN = CustomEvent;
</span><span class="boring">    type OUT = CustomEvent;
</span><span class="boring">    type TimerState = u64;
</span><span class="boring">    type OperatorState = ();
</span><span class="boring">
</span><span class="boring">    fn handle_element(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        element: ArconElement&lt;Self::IN&gt;,
</span><span class="boring">        mut ctx: OperatorContext&lt;Self, impl Backend, impl ComponentDefinition&gt;,
</span><span class="boring">    ) -&gt; OperatorResult&lt;()&gt; {
</span><span class="boring">        let current_time = ctx.current_time()?;
</span><span class="boring">        let key = element.data.get_key();
</span><span class="boring">        let time = current_time + 1000;
</span><span class="boring">
</span><span class="boring">        if let Err(err) = ctx.schedule_at(key, time, element.data.id) {
</span><span class="boring">            error!(ctx.log(), &quot;Failed to schedule timer with err {}&quot;, err);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ctx.output(element);
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_timeout(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        timeout: Self::TimerState,
</span><span class="boring">        ctx: OperatorContext&lt;Self, impl Backend, impl ComponentDefinition&gt;,
</span><span class="boring">    ) -&gt; OperatorResult&lt;()&gt; {
</span><span class="boring">        info!(ctx.log(), &quot;Got a timer timeout for {:?}&quot;, timeout);
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    ignore_persist!();
</span><span class="boring">
</span><span class="boring">    fn state(&amp;mut self) -&gt; &amp;mut Self::OperatorState {
</span><span class="boring">        &amp;mut self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let mut pipeline = Pipeline::default()
        .collection((0..10000000).collect::&lt;Vec&lt;u64&gt;&gt;(), |conf| {
            conf.set_timestamp_extractor(|x: &amp;u64| *x);
        })
        .operator(OperatorBuilder {
            constructor: Arc::new(|_| MyOperator::default()),
            conf: Default::default(),
        })
        .operator(OperatorBuilder {
            constructor: Arc::new(|_| TimerOperator::default()),
            conf: Default::default(),
        })
        .build();
<span class="boring">
</span><span class="boring">    pipeline.start();
</span><span class="boring">    pipeline.await_termination();
</span><span class="boring">}
</span></code></pre>
<h1><a class="header" href="#pipeline-1" id="pipeline-1">Pipeline</a></h1>
<p>An Arcon Pipeline is where everything starts from. It contains all necessary runtime components, 
configurations, and provides access to a set of stream <code>Sources</code>.</p>
<ul>
<li><a href="pipeline/configuration.html">Configuration</a></li>
<li><a href="pipeline/source.html">Sources</a></li>
<li><a href="pipeline/stream.html">Stream</a></li>
<li><a href="pipeline/state.html">State Access</a></li>
</ul>
<h1><a class="header" href="#configuration" id="configuration">Configuration</a></h1>
<p>Arcon uses HOCON for its configuration.</p>
<p>Full list of possible configurations may be found <a href="https://github.com/cda-group/arcon/blob/master/src/conf/mod.rs">here</a>.</p>
<h2><a class="header" href="#example-configuration-file" id="example-configuration-file">Example Configuration file</a></h2>
<p>This configuration file changes the interval for both watermarks and epochs, but also changes
the batching of events to a maximum of 1024 events.</p>
<p>All other configuration parameters are set to their default values.</p>
<pre><code class="language-rust edition2018 no_run noplaypen">{
  watermark_interval: 1000,
  epoch_interval: 15000,
  channel_batch_size: 1024,
  execution_mode: &quot;Local&quot;,
}
</code></pre>
<h2><a class="header" href="#loading-configuration-from-file" id="loading-configuration-from-file">Loading Configuration from file</a></h2>
<pre><code class="language-rust edition2018 no_run noplaypen">use arcon::prelude::*;

fn main() {
    let path = &quot;guide/examples/arcon.conf&quot;;
    let conf = ArconConf::from_file(path).expect(&quot;could not read conf&quot;);
    let _pipeline = Pipeline::with_conf(conf);
}
</code></pre>
<h1><a class="header" href="#sources" id="sources">Sources</a></h1>
<p>This section will cover the data sources of Arcon. 
Sources are defined through Arcon’s Pipeline object. Either by specifying a pre-defined one 
or adding your own <code>Source</code> implementation.</p>
<ul>
<li><a href="pipeline/source.html#source-configuration">Source Configuration</a></li>
<li><a href="pipeline/source.html#pre-defined-sources">Pre-defined Sources</a></li>
<li><a href="pipeline/source.html#creating-a-custom-source">Creating a custom Source</a></li>
</ul>
<h2><a class="header" href="#source-configuration" id="source-configuration">Source Configuration</a></h2>
<p>Whether you are using a pre-defined source or your own. You will have the chance
to configure a <code>SourceConf</code> object. Time in Arcon is by default based on event time.
However, if you wish to swap to Process Time, you may do so by choosing <code>ArconTime::Process</code>.
Note that if you are using <code>ArconTime::Event</code>, then a Timestamp Extractor also needs to be set. See down 
below that shows an example of a Source that is working with the primitive <code>u64</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use arcon::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut pipeline = Pipeline::default()
</span><span class="boring">        .collection((0..100).collect::&lt;Vec&lt;u64&gt;&gt;(), |conf| {
</span>            conf.set_arcon_time(ArconTime::Event);
            conf.set_timestamp_extractor(|x: &amp;u64| *x);
<span class="boring">        })
</span><span class="boring">        .operator(OperatorBuilder {
</span><span class="boring">            constructor: Arc::new(|_| Filter::new(|x| *x &gt; 50)),
</span><span class="boring">            conf: OperatorConf {
</span><span class="boring">                parallelism_strategy: ParallelismStrategy::Static(1),
</span><span class="boring">                ..Default::default()
</span><span class="boring">            },
</span><span class="boring">        })
</span><span class="boring">        .to_console()
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    pipeline.start();
</span><span class="boring">    pipeline.await_termination();
</span><span class="boring">}
</span></code></pre>
<h2><a class="header" href="#pre-defined-sources" id="pre-defined-sources">Pre-defined Sources</a></h2>
<h3><a class="header" href="#collection" id="collection">Collection</a></h3>
<p>A Collection source is mostly for testing things out.
It takes a <code>Vec&lt;A&gt;</code> as argument where <code>A: ArconType</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen">use arcon::prelude::*;

fn main() {
    let mut pipeline = Pipeline::default()
        .collection((0..100).collect::&lt;Vec&lt;u64&gt;&gt;(), |conf| {
            conf.set_arcon_time(ArconTime::Event);
            conf.set_timestamp_extractor(|x: &amp;u64| *x);
        })
        .operator(OperatorBuilder {
            constructor: Arc::new(|_| Filter::new(|x| *x &gt; 50)),
            conf: Default::default(),
        })
        .operator(OperatorBuilder {
            constructor: Arc::new(|_| Map::new(|x| x + 10)),
            conf: Default::default(),
        })
        .to_console()
        .build();

    pipeline.start();
    pipeline.await_termination();
}
</code></pre>
<h3><a class="header" href="#file" id="file">File</a></h3>
<p>The example code reads u64s from a file called
<code>file_source_data</code>. The file source requires your input data to implement <code>ArconType</code> but also
Rust’s <code>std::str::FromStr</code> type.</p>
<pre><code class="language-rust edition2018 no_run noplaypen">use arcon::prelude::*;

fn main() {
    let mut pipeline = Pipeline::default()
        .file(&quot;file_source_data&quot;, |cfg| {
            cfg.set_arcon_time(ArconTime::Process);
        })
        .operator(OperatorBuilder {
            constructor: Arc::new(|_| FlatMap::new(|x| (0..x))),
            conf: Default::default(),
        })
        .to_console()
        .build();

    pipeline.start();
    pipeline.await_termination();
}
</code></pre>
<h2><a class="header" href="#creating-a-custom-source" id="creating-a-custom-source">Creating a custom Source</a></h2>
<p>To be added.</p>
<h1><a class="header" href="#stream-api" id="stream-api">Stream API</a></h1>
<p>A <code>Stream</code> in Arcon represents an unbounded or bounded stream of data. </p>
<p>Users may add a transformation on one Stream to produce another. The sequence of transformations
is added to a dataflow graph which is then later used to build the final Pipeline.</p>
<p>Streams are initially created from Arcon sources.</p>
<p>The section is split into the follow sub-sections: </p>
<ul>
<li><a href="pipeline/stream.html#operator-builder">Operator Builder</a></li>
<li><a href="pipeline/stream.html#pre-defined-operators">Pre-defined Operators</a></li>
<li><a href="pipeline/stream.html#running-a-pipeline">Running a Pipeline</a></li>
<li><a href="pipeline/stream.html#basic-pipeline">Basic Pipeline</a></li>
</ul>
<h2><a class="header" href="#operator-builder" id="operator-builder">Operator Builder</a></h2>
<p>An Operator Builder is used to define an Operator in Arcon pipeline. The builder requires two fields, a constructor and 
configuration.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use arcon::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut pipeline = Pipeline::default()
</span><span class="boring">        .collection((0..100).collect::&lt;Vec&lt;u64&gt;&gt;(), |conf| {
</span><span class="boring">            conf.set_arcon_time(ArconTime::Event);
</span><span class="boring">            conf.set_timestamp_extractor(|x: &amp;u64| *x);
</span><span class="boring">        })
</span>        .operator(OperatorBuilder {
            constructor: Arc::new(|_| Filter::new(|x| *x &gt; 50)),
            conf: OperatorConf {
                parallelism_strategy: ParallelismStrategy::Static(1),
                ..Default::default()
            },
        })
<span class="boring">        .to_console()
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    pipeline.start();
</span><span class="boring">    pipeline.await_termination();
</span><span class="boring">}
</span></code></pre>
<h3><a class="header" href="#operator-constructor" id="operator-constructor">Operator Constructor</a></h3>
<p>The constructor of the builder has access to a <code>Backend</code> object. If your operator is stateless, you may simply
ignore it as it has been done above. If the <code>rocksdb</code> feature is enabled, then Rocks will be used as the default <code>Backend</code>,
otherwise Arcon defaults to <code>Sled</code>. If you wish to configure a specific Backend, then simply annotate it with <code>|backend: Arc&lt;Rocks&gt;|</code>.</p>
<h3><a class="header" href="#operator-configuration" id="operator-configuration">Operator Configuration</a></h3>
<p>Currently the configuration has two possible parameters. (1) ParallelismStrategy, where you may configure a static one <code>ParallelismStrategy::Static(usize)</code>
or managed <code>ParallelismStrategy::Managed</code>. Note that only the Static strategy works for now; (2) StreamKind defines the type of Stream
we are dealing with. Arcon is for now only focusing on Keyed streams and therefore the default StreamKind is <code>StreamKind::Keyed</code>.</p>
<p>You may configure a default operator configuration through <code>conf: Default::default()</code>.</p>
<h2><a class="header" href="#pre-defined-operators" id="pre-defined-operators">Pre-defined Operators</a></h2>
<p>Arcon comes with a set of high-level function operators. All of the operators can either be stateless using 
the <code>new</code> constructor or stateful through<code>stateful</code>.  In the latter, you will need to pass both the User-defined Function and
an <code>ArconState</code> object.</p>
<h3><a class="header" href="#map" id="map">Map</a></h3>
<p>An Operator that maps <code>IN: ArconType</code> to <code>OUT: ArconType</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen">Map::new(|x: u64| x + 10)
</code></pre>
<h3><a class="header" href="#mapinplace" id="mapinplace">MapInPlace</a></h3>
<p>An Operator that maps in-place on <code>IN: ArconType</code> and outputs the same type.</p>
<pre><code class="language-rust edition2018 no_run noplaypen">MapInPlace::new(|x: &amp;mut u64| *x + 10)
</code></pre>
<h3><a class="header" href="#filter" id="filter">Filter</a></h3>
<p>An Operator that filters away <code>IN: ArconType</code> based on a predicate.</p>
<pre><code class="language-rust edition2018 no_run noplaypen">Filter::new(|x: &amp;u64| *x &gt; 10)
</code></pre>
<h3><a class="header" href="#flatmap" id="flatmap">Flatmap</a></h3>
<p>An Operator that accepts a single <code>IN: ArconType</code> and outputs N elements of <code>OUT: ArconType</code>.
The expected output type of the function is an <code>IntoIterator</code> where each Item is of type <code>OUT</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen">Flatmap::new(|x: u64| (0..x))
</code></pre>
<h2><a class="header" href="#running-a-pipeline" id="running-a-pipeline">Running a Pipeline</a></h2>
<p>Once you are done with adding transformations and want to build the pipeline, the <code>build()</code> function on a Stream type
will construct the Dataflow components and return an <code>AssembledPipeline</code>.
Arcon does not require any explicit sink. If you wish to debug the output of the last Operator, then see the <code>to_console()</code> function.</p>
<p>Note that an <code>AssembledPipeline</code> does not start processing data until it has been started.</p>
<h2><a class="header" href="#basic-pipeline" id="basic-pipeline">Basic Pipeline</a></h2>
<pre><code class="language-rust edition2018 no_run noplaypen">use arcon::prelude::*;

fn main() {
    let mut pipeline = Pipeline::default()
        .collection((0..100).collect::&lt;Vec&lt;u64&gt;&gt;(), |conf| {
            conf.set_arcon_time(ArconTime::Event);
            conf.set_timestamp_extractor(|x: &amp;u64| *x);
        })
        .operator(OperatorBuilder {
            constructor: Arc::new(|_| Filter::new(|x| *x &gt; 50)),
            conf: Default::default(),
        })
        .operator(OperatorBuilder {
            constructor: Arc::new(|_| Map::new(|x| x + 10)),
            conf: Default::default(),
        })
        .to_console()
        .build();

    pipeline.start();
    pipeline.await_termination();
}
</code></pre>
<h1><a class="header" href="#state-backends" id="state-backends">State Backends</a></h1>
<p>Arcon’s state management features are implemented in the <code>arcon_state</code> crate. </p>
<p>If no other backend feature has been turned on, then <a href="https://github.com/spacejam/sled">sled</a> is used as the default backend.
However, if the <code>rocksdb</code> feature is on, then RocksDB will be used as the default as it is more mature and in most cases performs better.</p>
<h2><a class="header" href="#sled" id="sled">Sled</a></h2>
<p>To be added.</p>
<h2><a class="header" href="#rocksdb" id="rocksdb">RocksDB</a></h2>
<p>To be added.</p>
<h1><a class="header" href="#state-indexes" id="state-indexes">State Indexes</a></h1>
<p>We will use the following ArconState object to showcase the different indexes.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use arcon::prelude::*;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">
</span>#[derive(ArconState)]
pub struct StreamState&lt;B: Backend&gt; {
    counter: LazyValue&lt;u64, B&gt;,
    counters_map: HashTable&lt;u64, String, B&gt;,
    counters: EagerAppender&lt;u64, B&gt;,
}

impl&lt;B: Backend&gt; StateConstructor for StreamState&lt;B&gt; {
    type BackendType = B;

    fn new(backend: Arc&lt;Self::BackendType&gt;) -&gt; Self {
        Self {
            counter: LazyValue::new(&quot;_counter&quot;, backend.clone()),
            counters_map: HashTable::new(&quot;_counters_map&quot;, backend.clone()),
            counters: EagerAppender::new(&quot;_counters&quot;, backend),
        }
    }
}

<span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">    let test_dir = tempfile::tempdir().unwrap();
</span><span class="boring">    let path = test_dir.path();
</span><span class="boring">    let backend = Arc::new(Sled::create(path).unwrap());
</span><span class="boring">
</span><span class="boring">    let mut state = StreamState::new(backend);
</span><span class="boring">
</span><span class="boring">    // PUT, GET, RMW, and CLEAR
</span><span class="boring">
</span><span class="boring">    state.counter().put(10)?;
</span><span class="boring">
</span><span class="boring">    assert_eq!(state.counter().rmw(|v| *v += 10).is_ok(), true);
</span><span class="boring">
</span><span class="boring">    let counter = state.counter().get()?;
</span><span class="boring">    assert_eq!(counter.unwrap().as_ref(), &amp;20);
</span><span class="boring">
</span><span class="boring">    state.counter().clear()?;
</span><span class="boring">
</span><span class="boring">    let counter = state.counter().get()?;
</span><span class="boring">    assert_eq!(counter, None);
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    // PUT, GET, RMW, and REMOVE
</span><span class="boring">
</span><span class="boring">    state.counters_map().put(1, String::from(&quot;hello&quot;))?;
</span><span class="boring">
</span><span class="boring">    assert!(state.counters_map().get(&amp;5).unwrap().is_none());
</span><span class="boring">
</span><span class="boring">    state
</span><span class="boring">        .counters_map()
</span><span class="boring">        .rmw(&amp;1, || String::from(&quot;default&quot;), |s| s.push_str(&quot; world&quot;))?;
</span><span class="boring">
</span><span class="boring">    assert_eq!(
</span><span class="boring">        state.counters_map().get(&amp;1).unwrap(),
</span><span class="boring">        Some(&amp;String::from(&quot;hello world&quot;))
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(
</span><span class="boring">        state.counters_map().remove(&amp;1).unwrap(),
</span><span class="boring">        Some(String::from(&quot;hello world&quot;))
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    // APPEND, CONSUME
</span><span class="boring">
</span><span class="boring">    state.counters().append(1)?;
</span><span class="boring">    state.counters().append(2)?;
</span><span class="boring">    state.counters().append(3)?;
</span><span class="boring">
</span><span class="boring">    assert_eq!(state.counters().consume().unwrap(), vec![1, 2, 3]);
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre>
<h2><a class="header" href="#value" id="value">Value</a></h2>
<p>A value index holds a single ArconType <code>T</code> and provides a set of operations to handle the value.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use arcon::prelude::*;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">
</span><span class="boring">#[derive(ArconState)]
</span><span class="boring">pub struct StreamState&lt;B: Backend&gt; {
</span><span class="boring">    counter: LazyValue&lt;u64, B&gt;,
</span><span class="boring">    counters_map: HashTable&lt;u64, String, B&gt;,
</span><span class="boring">    counters: EagerAppender&lt;u64, B&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;B: Backend&gt; StateConstructor for StreamState&lt;B&gt; {
</span><span class="boring">    type BackendType = B;
</span><span class="boring">
</span><span class="boring">    fn new(backend: Arc&lt;Self::BackendType&gt;) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            counter: LazyValue::new(&quot;_counter&quot;, backend.clone()),
</span><span class="boring">            counters_map: HashTable::new(&quot;_counters_map&quot;, backend.clone()),
</span><span class="boring">            counters: EagerAppender::new(&quot;_counters&quot;, backend),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">    let test_dir = tempfile::tempdir().unwrap();
</span><span class="boring">    let path = test_dir.path();
</span><span class="boring">    let backend = Arc::new(Sled::create(path).unwrap());
</span><span class="boring">
</span><span class="boring">    let mut state = StreamState::new(backend);
</span><span class="boring">
</span>    // PUT, GET, RMW, and CLEAR

    state.counter().put(10)?;

    assert_eq!(state.counter().rmw(|v| *v += 10).is_ok(), true);

    let counter = state.counter().get()?;
    assert_eq!(counter.unwrap().as_ref(), &amp;20);

    state.counter().clear()?;

    let counter = state.counter().get()?;
    assert_eq!(counter, None);

<span class="boring">
</span><span class="boring">    // PUT, GET, RMW, and REMOVE
</span><span class="boring">
</span><span class="boring">    state.counters_map().put(1, String::from(&quot;hello&quot;))?;
</span><span class="boring">
</span><span class="boring">    assert!(state.counters_map().get(&amp;5).unwrap().is_none());
</span><span class="boring">
</span><span class="boring">    state
</span><span class="boring">        .counters_map()
</span><span class="boring">        .rmw(&amp;1, || String::from(&quot;default&quot;), |s| s.push_str(&quot; world&quot;))?;
</span><span class="boring">
</span><span class="boring">    assert_eq!(
</span><span class="boring">        state.counters_map().get(&amp;1).unwrap(),
</span><span class="boring">        Some(&amp;String::from(&quot;hello world&quot;))
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(
</span><span class="boring">        state.counters_map().remove(&amp;1).unwrap(),
</span><span class="boring">        Some(String::from(&quot;hello world&quot;))
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    // APPEND, CONSUME
</span><span class="boring">
</span><span class="boring">    state.counters().append(1)?;
</span><span class="boring">    state.counters().append(2)?;
</span><span class="boring">    state.counters().append(3)?;
</span><span class="boring">
</span><span class="boring">    assert_eq!(state.counters().consume().unwrap(), vec![1, 2, 3]);
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre>
<p>There is no <code>Eager</code> version of Value provided as it does not make much sense while 
dealing with a single object.</p>
<h2><a class="header" href="#hashtable" id="hashtable">HashTable</a></h2>
<p>An index for managing an unordered hash index. </p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use arcon::prelude::*;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">
</span><span class="boring">#[derive(ArconState)]
</span><span class="boring">pub struct StreamState&lt;B: Backend&gt; {
</span><span class="boring">    counter: LazyValue&lt;u64, B&gt;,
</span><span class="boring">    counters_map: HashTable&lt;u64, String, B&gt;,
</span><span class="boring">    counters: EagerAppender&lt;u64, B&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;B: Backend&gt; StateConstructor for StreamState&lt;B&gt; {
</span><span class="boring">    type BackendType = B;
</span><span class="boring">
</span><span class="boring">    fn new(backend: Arc&lt;Self::BackendType&gt;) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            counter: LazyValue::new(&quot;_counter&quot;, backend.clone()),
</span><span class="boring">            counters_map: HashTable::new(&quot;_counters_map&quot;, backend.clone()),
</span><span class="boring">            counters: EagerAppender::new(&quot;_counters&quot;, backend),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">    let test_dir = tempfile::tempdir().unwrap();
</span><span class="boring">    let path = test_dir.path();
</span><span class="boring">    let backend = Arc::new(Sled::create(path).unwrap());
</span><span class="boring">
</span><span class="boring">    let mut state = StreamState::new(backend);
</span><span class="boring">
</span><span class="boring">    // PUT, GET, RMW, and CLEAR
</span><span class="boring">
</span><span class="boring">    state.counter().put(10)?;
</span><span class="boring">
</span><span class="boring">    assert_eq!(state.counter().rmw(|v| *v += 10).is_ok(), true);
</span><span class="boring">
</span><span class="boring">    let counter = state.counter().get()?;
</span><span class="boring">    assert_eq!(counter.unwrap().as_ref(), &amp;20);
</span><span class="boring">
</span><span class="boring">    state.counter().clear()?;
</span><span class="boring">
</span><span class="boring">    let counter = state.counter().get()?;
</span><span class="boring">    assert_eq!(counter, None);
</span><span class="boring">
</span><span class="boring">
</span>    // PUT, GET, RMW, and REMOVE

    state.counters_map().put(1, String::from(&quot;hello&quot;))?;

    assert!(state.counters_map().get(&amp;5).unwrap().is_none());

    state
        .counters_map()
        .rmw(&amp;1, || String::from(&quot;default&quot;), |s| s.push_str(&quot; world&quot;))?;

    assert_eq!(
        state.counters_map().get(&amp;1).unwrap(),
        Some(&amp;String::from(&quot;hello world&quot;))
    );

    assert_eq!(
        state.counters_map().remove(&amp;1).unwrap(),
        Some(String::from(&quot;hello world&quot;))
    );

<span class="boring">
</span><span class="boring">    // APPEND, CONSUME
</span><span class="boring">
</span><span class="boring">    state.counters().append(1)?;
</span><span class="boring">    state.counters().append(2)?;
</span><span class="boring">    state.counters().append(3)?;
</span><span class="boring">
</span><span class="boring">    assert_eq!(state.counters().consume().unwrap(), vec![1, 2, 3]);
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre>
<p>An index for appending data which then later can be consumed.</p>
<h2><a class="header" href="#appender" id="appender">Appender</a></h2>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use arcon::prelude::*;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">
</span><span class="boring">#[derive(ArconState)]
</span><span class="boring">pub struct StreamState&lt;B: Backend&gt; {
</span><span class="boring">    counter: LazyValue&lt;u64, B&gt;,
</span><span class="boring">    counters_map: HashTable&lt;u64, String, B&gt;,
</span><span class="boring">    counters: EagerAppender&lt;u64, B&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;B: Backend&gt; StateConstructor for StreamState&lt;B&gt; {
</span><span class="boring">    type BackendType = B;
</span><span class="boring">
</span><span class="boring">    fn new(backend: Arc&lt;Self::BackendType&gt;) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            counter: LazyValue::new(&quot;_counter&quot;, backend.clone()),
</span><span class="boring">            counters_map: HashTable::new(&quot;_counters_map&quot;, backend.clone()),
</span><span class="boring">            counters: EagerAppender::new(&quot;_counters&quot;, backend),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">    let test_dir = tempfile::tempdir().unwrap();
</span><span class="boring">    let path = test_dir.path();
</span><span class="boring">    let backend = Arc::new(Sled::create(path).unwrap());
</span><span class="boring">
</span><span class="boring">    let mut state = StreamState::new(backend);
</span><span class="boring">
</span><span class="boring">    // PUT, GET, RMW, and CLEAR
</span><span class="boring">
</span><span class="boring">    state.counter().put(10)?;
</span><span class="boring">
</span><span class="boring">    assert_eq!(state.counter().rmw(|v| *v += 10).is_ok(), true);
</span><span class="boring">
</span><span class="boring">    let counter = state.counter().get()?;
</span><span class="boring">    assert_eq!(counter.unwrap().as_ref(), &amp;20);
</span><span class="boring">
</span><span class="boring">    state.counter().clear()?;
</span><span class="boring">
</span><span class="boring">    let counter = state.counter().get()?;
</span><span class="boring">    assert_eq!(counter, None);
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    // PUT, GET, RMW, and REMOVE
</span><span class="boring">
</span><span class="boring">    state.counters_map().put(1, String::from(&quot;hello&quot;))?;
</span><span class="boring">
</span><span class="boring">    assert!(state.counters_map().get(&amp;5).unwrap().is_none());
</span><span class="boring">
</span><span class="boring">    state
</span><span class="boring">        .counters_map()
</span><span class="boring">        .rmw(&amp;1, || String::from(&quot;default&quot;), |s| s.push_str(&quot; world&quot;))?;
</span><span class="boring">
</span><span class="boring">    assert_eq!(
</span><span class="boring">        state.counters_map().get(&amp;1).unwrap(),
</span><span class="boring">        Some(&amp;String::from(&quot;hello world&quot;))
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(
</span><span class="boring">        state.counters_map().remove(&amp;1).unwrap(),
</span><span class="boring">        Some(String::from(&quot;hello world&quot;))
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">
</span>    // APPEND, CONSUME

    state.counters().append(1)?;
    state.counters().append(2)?;
    state.counters().append(3)?;

    assert_eq!(state.counters().consume().unwrap(), vec![1, 2, 3]);

<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre>
<h1><a class="header" href="#accessing-state" id="accessing-state">Accessing State</a></h1>
<p>This section covers different approaches to accessing state of a live Arcon application.</p>
<p>Arcon State is identified through a <code>StateID</code> which is an type alias
for a String. The state id of an <code>ArconState</code> object is its struct name.</p>
<ul>
<li><a href="pipeline/state.html#snapshot">Snapshot</a></li>
<li><a href="pipeline/state.html#watching-from-a-thread">Watching from a thread</a></li>
<li><a href="pipeline/state.html#watching-from-a-kompact-component">Watching from a Kompact component</a></li>
<li><a href="pipeline/state.html#executing-sql-queries">Executing SQL queries</a></li>
</ul>
<h2><a class="header" href="#snapshot" id="snapshot">Snapshot</a></h2>
<p>Arcon uses a epoch snapshotting protocol in order to take consistent state snapshots of an application.
Once a Snapshot has been committed, it will be available for access outside the live execution.</p>
<h2><a class="header" href="#state-setup" id="state-setup">State Setup</a></h2>
<p>We will use the following state for this section.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use arcon::prelude::*;
</span><span class="boring">use examples::SnapshotComponent;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">
</span><span class="boring">#[cfg_attr(feature = &quot;arcon_serde&quot;, derive(serde::Deserialize, serde::Serialize))]
</span><span class="boring">#[cfg_attr(feature = &quot;unsafe_flight&quot;, derive(abomonation_derive::Abomonation))]
</span><span class="boring">#[derive(Arcon, Arrow, prost::Message, Copy, Clone)]
</span><span class="boring">#[arcon(unsafe_ser_id = 12, reliable_ser_id = 13, version = 1, keys = &quot;id&quot;)]
</span><span class="boring">pub struct Event {
</span><span class="boring">    #[prost(uint64)]
</span><span class="boring">    pub id: u64,
</span><span class="boring">    #[prost(float)]
</span><span class="boring">    pub data: f32,
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(ArconState)]
pub struct MyState&lt;B: Backend&gt; {
    #[table = &quot;events&quot;]
    events: EagerValue&lt;Event, B&gt;,
}

impl&lt;B: Backend&gt; StateConstructor for MyState&lt;B&gt; {
    type BackendType = B;

    fn new(backend: Arc&lt;Self::BackendType&gt;) -&gt; Self {
        Self {
            events: EagerValue::new(&quot;_events&quot;, backend),
        }
    }
}

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let conf = ArconConf {
</span><span class="boring">        epoch_interval: 2500,
</span><span class="boring">        ctrl_system_host: Some(&quot;127.0.0.1:2000&quot;.to_string()),
</span><span class="boring">        ..Default::default()
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let mut pipeline = Pipeline::with_conf(conf)
</span><span class="boring">        .collection(
</span><span class="boring">            (0..1000000)
</span><span class="boring">                .map(|x| Event { id: x, data: 1.5 })
</span><span class="boring">                .collect::&lt;Vec&lt;Event&gt;&gt;(),
</span><span class="boring">            |conf| {
</span><span class="boring">                conf.set_timestamp_extractor(|x: &amp;Event| x.id);
</span><span class="boring">            },
</span><span class="boring">        )
</span><span class="boring">        .operator(OperatorBuilder {
</span><span class="boring">            constructor: Arc::new(|backend| {
</span><span class="boring">                Map::stateful(MyState::new(backend), |event, state| {
</span><span class="boring">                    state.events().put(event)?;
</span><span class="boring">                    Ok(event)
</span><span class="boring">                })
</span><span class="boring">            }),
</span><span class="boring">            conf: Default::default(),
</span><span class="boring">        })
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    pipeline.watch(|epoch: u64, _: MyState&lt;Sled&gt;| {
</span><span class="boring">        println!(&quot;Got state object for epoch {}&quot;, epoch);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let kompact_system = KompactConfig::default().build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">    // Create Kompact component to receive snapshots
</span><span class="boring">    let snapshot_comp = kompact_system.create(SnapshotComponent::new);
</span><span class="boring">
</span><span class="boring">    kompact_system
</span><span class="boring">        .start_notify(&amp;snapshot_comp)
</span><span class="boring">        .wait_timeout(std::time::Duration::from_millis(200))
</span><span class="boring">        .expect(&quot;Failed to start component&quot;);
</span><span class="boring">
</span><span class="boring">    pipeline.watch_with::&lt;MyState&lt;Sled&gt;&gt;(snapshot_comp);
</span><span class="boring">
</span><span class="boring">    pipeline.start();
</span><span class="boring">    pipeline.await_termination();
</span><span class="boring">}
</span></code></pre>
<h2><a class="header" href="#watching-from-a-thread" id="watching-from-a-thread">Watching from a thread</a></h2>
<p>With the <code>watch</code> command, we can get access to some <code>ArconState</code> from our application per Epoch.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use arcon::prelude::*;
</span><span class="boring">use examples::SnapshotComponent;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">
</span><span class="boring">#[cfg_attr(feature = &quot;arcon_serde&quot;, derive(serde::Deserialize, serde::Serialize))]
</span><span class="boring">#[cfg_attr(feature = &quot;unsafe_flight&quot;, derive(abomonation_derive::Abomonation))]
</span><span class="boring">#[derive(Arcon, Arrow, prost::Message, Copy, Clone)]
</span><span class="boring">#[arcon(unsafe_ser_id = 12, reliable_ser_id = 13, version = 1, keys = &quot;id&quot;)]
</span><span class="boring">pub struct Event {
</span><span class="boring">    #[prost(uint64)]
</span><span class="boring">    pub id: u64,
</span><span class="boring">    #[prost(float)]
</span><span class="boring">    pub data: f32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ArconState)]
</span><span class="boring">pub struct MyState&lt;B: Backend&gt; {
</span><span class="boring">    #[table = &quot;events&quot;]
</span><span class="boring">    events: EagerValue&lt;Event, B&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;B: Backend&gt; StateConstructor for MyState&lt;B&gt; {
</span><span class="boring">    type BackendType = B;
</span><span class="boring">
</span><span class="boring">    fn new(backend: Arc&lt;Self::BackendType&gt;) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            events: EagerValue::new(&quot;_events&quot;, backend),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let conf = ArconConf {
</span><span class="boring">        epoch_interval: 2500,
</span><span class="boring">        ctrl_system_host: Some(&quot;127.0.0.1:2000&quot;.to_string()),
</span><span class="boring">        ..Default::default()
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let mut pipeline = Pipeline::with_conf(conf)
</span><span class="boring">        .collection(
</span><span class="boring">            (0..1000000)
</span><span class="boring">                .map(|x| Event { id: x, data: 1.5 })
</span><span class="boring">                .collect::&lt;Vec&lt;Event&gt;&gt;(),
</span><span class="boring">            |conf| {
</span><span class="boring">                conf.set_timestamp_extractor(|x: &amp;Event| x.id);
</span><span class="boring">            },
</span><span class="boring">        )
</span><span class="boring">        .operator(OperatorBuilder {
</span><span class="boring">            constructor: Arc::new(|backend| {
</span><span class="boring">                Map::stateful(MyState::new(backend), |event, state| {
</span><span class="boring">                    state.events().put(event)?;
</span><span class="boring">                    Ok(event)
</span><span class="boring">                })
</span><span class="boring">            }),
</span><span class="boring">            conf: Default::default(),
</span><span class="boring">        })
</span><span class="boring">        .build();
</span><span class="boring">
</span>    pipeline.watch(|epoch: u64, _: MyState&lt;Sled&gt;| {
        println!(&quot;Got state object for epoch {}&quot;, epoch);
    });
<span class="boring">
</span><span class="boring">    let kompact_system = KompactConfig::default().build().expect(&quot;KompactSystem&quot;);
</span><span class="boring">    // Create Kompact component to receive snapshots
</span><span class="boring">    let snapshot_comp = kompact_system.create(SnapshotComponent::new);
</span><span class="boring">
</span><span class="boring">    kompact_system
</span><span class="boring">        .start_notify(&amp;snapshot_comp)
</span><span class="boring">        .wait_timeout(std::time::Duration::from_millis(200))
</span><span class="boring">        .expect(&quot;Failed to start component&quot;);
</span><span class="boring">
</span><span class="boring">    pipeline.watch_with::&lt;MyState&lt;Sled&gt;&gt;(snapshot_comp);
</span><span class="boring">
</span><span class="boring">    pipeline.start();
</span><span class="boring">    pipeline.await_termination();
</span><span class="boring">}
</span></code></pre>
<h2><a class="header" href="#watching-from-a-kompact-component" id="watching-from-a-kompact-component">Watching from a Kompact component</a></h2>
<p>If you have a <a href="https://github.com/kompics/kompact">Kompact</a> application that needs to act on the data from an Arcon application.
Then it is possible to register components to receive Snapshots. However it is up to the 
external component to construct the <code>ArconState</code> from the received <code>Snapshot</code>.</p>
<p>Example Component</p>
<pre><code class="language-rust edition2018 no_run noplaypen">use arcon::prelude::*;

impl Default for SnapshotComponent {
    fn default() -&gt; Self {
        Self::new()
    }
}

#[derive(ComponentDefinition)]
pub struct SnapshotComponent {
    ctx: ComponentContext&lt;Self&gt;,
}

impl SnapshotComponent {
    pub fn new() -&gt; Self {
        Self {
            ctx: ComponentContext::uninitialised(),
        }
    }
}

impl ComponentLifecycle for SnapshotComponent {
    fn on_start(&amp;mut self) -&gt; Handled {
        Handled::Ok
    }
}

impl Actor for SnapshotComponent {
    type Message = Snapshot;

    fn receive_local(&amp;mut self, msg: Self::Message) -&gt; Handled {
        info!(self.ctx.log(), &quot;I received Snapshot {:?}&quot;, msg);
        Handled::Ok
    }

    fn receive_network(&amp;mut self, _: NetMessage) -&gt; Handled {
        unreachable!();
    }
}
</code></pre>
<p>We can then add this component to receive Snapshots by executing <code>watch_with</code> which
takes a state id and and any Kompact component that implements <code>Message = Snapshot</code>.
The snippet below shows how an example of how to do this.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">use arcon::prelude::*;
</span><span class="boring">use examples::SnapshotComponent;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">
</span><span class="boring">#[cfg_attr(feature = &quot;arcon_serde&quot;, derive(serde::Deserialize, serde::Serialize))]
</span><span class="boring">#[cfg_attr(feature = &quot;unsafe_flight&quot;, derive(abomonation_derive::Abomonation))]
</span><span class="boring">#[derive(Arcon, Arrow, prost::Message, Copy, Clone)]
</span><span class="boring">#[arcon(unsafe_ser_id = 12, reliable_ser_id = 13, version = 1, keys = &quot;id&quot;)]
</span><span class="boring">pub struct Event {
</span><span class="boring">    #[prost(uint64)]
</span><span class="boring">    pub id: u64,
</span><span class="boring">    #[prost(float)]
</span><span class="boring">    pub data: f32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ArconState)]
</span><span class="boring">pub struct MyState&lt;B: Backend&gt; {
</span><span class="boring">    #[table = &quot;events&quot;]
</span><span class="boring">    events: EagerValue&lt;Event, B&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;B: Backend&gt; StateConstructor for MyState&lt;B&gt; {
</span><span class="boring">    type BackendType = B;
</span><span class="boring">
</span><span class="boring">    fn new(backend: Arc&lt;Self::BackendType&gt;) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            events: EagerValue::new(&quot;_events&quot;, backend),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let conf = ArconConf {
</span><span class="boring">        epoch_interval: 2500,
</span><span class="boring">        ctrl_system_host: Some(&quot;127.0.0.1:2000&quot;.to_string()),
</span><span class="boring">        ..Default::default()
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let mut pipeline = Pipeline::with_conf(conf)
</span><span class="boring">        .collection(
</span><span class="boring">            (0..1000000)
</span><span class="boring">                .map(|x| Event { id: x, data: 1.5 })
</span><span class="boring">                .collect::&lt;Vec&lt;Event&gt;&gt;(),
</span><span class="boring">            |conf| {
</span><span class="boring">                conf.set_timestamp_extractor(|x: &amp;Event| x.id);
</span><span class="boring">            },
</span><span class="boring">        )
</span><span class="boring">        .operator(OperatorBuilder {
</span><span class="boring">            constructor: Arc::new(|backend| {
</span><span class="boring">                Map::stateful(MyState::new(backend), |event, state| {
</span><span class="boring">                    state.events().put(event)?;
</span><span class="boring">                    Ok(event)
</span><span class="boring">                })
</span><span class="boring">            }),
</span><span class="boring">            conf: Default::default(),
</span><span class="boring">        })
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    pipeline.watch(|epoch: u64, _: MyState&lt;Sled&gt;| {
</span><span class="boring">        println!(&quot;Got state object for epoch {}&quot;, epoch);
</span><span class="boring">    });
</span><span class="boring">
</span>    let kompact_system = KompactConfig::default().build().expect(&quot;KompactSystem&quot;);
    // Create Kompact component to receive snapshots
    let snapshot_comp = kompact_system.create(SnapshotComponent::new);

    kompact_system
        .start_notify(&amp;snapshot_comp)
        .wait_timeout(std::time::Duration::from_millis(200))
        .expect(&quot;Failed to start component&quot;);

    pipeline.watch_with::&lt;MyState&lt;Sled&gt;&gt;(snapshot_comp);
<span class="boring">
</span><span class="boring">    pipeline.start();
</span><span class="boring">    pipeline.await_termination();
</span><span class="boring">}
</span></code></pre>
<h2><a class="header" href="#executing-sql-queries" id="executing-sql-queries">Executing SQL queries</a></h2>
<p>Feature not implemented yet!</p>
<h1><a class="header" href="#roadmap" id="roadmap">Roadmap</a></h1>
<h2><a class="header" href="#030" id="030">0.3.0</a></h2>
<ul>
<li>Arrow Support</li>
<li>SQL + Arrow Flight Capabilities on Consistent Snapshots</li>
<li>Kafka Support</li>
<li>Stabilise API</li>
<li>Stabilise Local Execution</li>
</ul>
<h2><a class="header" href="#040" id="040">0.4.0</a></h2>
<ul>
<li>Distributed Execution</li>
<li>Distributed SQL + Arrow Flight Capabilities on Consistent Snapshots</li>
</ul>
<h1><a class="header" href="#project-info" id="project-info">Project Info</a></h1>
<p>Arcon is a research project developed at the KTH Royal Institute of Technology and at RISE Research Institutes of Sweden in Stockholm, Sweden.</p>
<h2><a class="header" href="#related-projects" id="related-projects">Related Projects</a></h2>
<ul>
<li><a href="https://github.com/kompics/kompact">Kompact</a>: A hybrid component and actor model framework.</li>
<li><a href="https://github.com/cda-group/arc">Arc</a>: Data analytics programming language that uses Arcon as its runtime.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
